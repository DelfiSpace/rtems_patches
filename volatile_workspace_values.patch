diff --git a/cpukit/include/rtems/score/wkspaceinitone.h b/cpukit/include/rtems/score/wkspaceinitone.h
index 0dc252a..cf0034b 100644
--- a/cpukit/include/rtems/score/wkspaceinitone.h
+++ b/cpukit/include/rtems/score/wkspaceinitone.h
@@ -37,12 +37,12 @@
 #ifndef _RTEMS_SCORE_WKSPACEINITONE_H
 #define _RTEMS_SCORE_WKSPACEINITONE_H
 
-#include <rtems/score/wkspace.h>
+#include <rtems/config.h>
 #include <rtems/score/assert.h>
 #include <rtems/score/heapimpl.h>
 #include <rtems/score/interr.h>
 #include <rtems/score/memory.h>
-#include <rtems/config.h>
+#include <rtems/score/wkspace.h>
 
 #ifdef __cplusplus
 extern "C" {
@@ -57,46 +57,39 @@ extern "C" {
  * This implementation should be used by BSPs which provide exactly one memory
  * area via _Memory_Get() to implement _Workspace_Handler_initialization().
  */
-static inline void _Workspace_Initialize_for_one_area( void )
-{
-  uintptr_t                 page_size;
-  uintptr_t                 wkspace_size;
-  uintptr_t                 wkspace_size_with_overhead;
+static inline void _Workspace_Initialize_for_one_area(void) {
+  volatile uintptr_t page_size;
+  volatile uintptr_t wkspace_size;
+  volatile uintptr_t wkspace_size_with_overhead;
   const Memory_Information *mem;
-  Memory_Area              *area;
-  uintptr_t                 free_size;
-  uintptr_t                 available_size;
+  volatile Memory_Area *area;
+  volatile uintptr_t free_size;
+  volatile uintptr_t available_size;
+  volatile uintptr_t size;
 
   page_size = CPU_HEAP_ALIGNMENT;
   wkspace_size = rtems_configuration_get_work_space_size();
-  wkspace_size_with_overhead = wkspace_size + _Heap_Area_overhead( page_size );
+  wkspace_size_with_overhead = wkspace_size + _Heap_Area_overhead(page_size);
 
   mem = _Memory_Get();
-  _Assert( _Memory_Get_count( mem ) == 1 );
+  _Assert(_Memory_Get_count(mem) == 1);
 
-  area = _Memory_Get_area( mem, 0 );
-  free_size = _Memory_Get_free_size( area );
+  area = _Memory_Get_area(mem, 0);
+  free_size = _Memory_Get_free_size(area);
 
-  if (
-    wkspace_size < wkspace_size_with_overhead &&
-    free_size >= wkspace_size_with_overhead
-  ) {
-    uintptr_t size;
+  if (wkspace_size < wkspace_size_with_overhead &&
+      free_size >= wkspace_size_with_overhead) {
 
-    if ( rtems_configuration_get_unified_work_area() ) {
+    if (rtems_configuration_get_unified_work_area()) {
       size = free_size;
     } else {
       size = wkspace_size_with_overhead;
     }
 
     available_size = _Heap_Initialize(
-      &_Workspace_Area,
-      _Memory_Get_free_begin( area ),
-      size,
-      page_size
-    );
+        &_Workspace_Area, _Memory_Get_free_begin(area), size, page_size);
 
-    _Memory_Consume( area, size );
+    _Memory_Consume(area, size);
   } else {
     /*
      * An unsigned integer overflow happened, or the available free memory is
@@ -105,11 +98,11 @@ static inline void _Workspace_Initialize_for_one_area( void )
     available_size = 0;
   }
 
-  if ( wkspace_size > available_size ) {
-    _Internal_error( INTERNAL_ERROR_TOO_LITTLE_WORKSPACE );
+  if (wkspace_size > available_size) {
+    _Internal_error(INTERNAL_ERROR_TOO_LITTLE_WORKSPACE);
   }
 
-  _Heap_Protection_set_delayed_free_fraction( &_Workspace_Area, 1 );
+  _Heap_Protection_set_delayed_free_fraction(&_Workspace_Area, 1);
 }
 
 #ifdef __cplusplus
